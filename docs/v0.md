이름: 점메추
설명: 점심 메뉴를 추천 해주는 서비스

- 시작페이지
    - 인원수, 메뉴 갯수, 메뉴 카테고리 설정
- 룰렛 돌림
    - 지도API 써서 근처에 있는 식당 기준으로
- 메뉴 갯수가 한개다
    - 바로 빵빠레!
- 메뉴 갯수가 여러개다
    - 처음에 설정한 인원수가 전부 투표 끝내면 바로 빵빠레
    - 한번 클릭하면 투표, 다시 같은거 클릭하면 투표 취소, 다른 메뉴 클릭하면 변경
- 링크복사버튼

시작, 룰렛, 투표 기능 별로 페이지를 나눈다.

---

구현 설계 (v0)
- 목표: 최소 기능으로 시작→룰렛→투표→결과 플로우를 단일 디바이스에서 순차적으로 완료한다.
- 최소 범위
    - 단일 디바이스, 순차 투표(한 사람씩 선택 후 확정), 외부 지도 API 미사용(모의 데이터 사용)
    - 후보 식당/메뉴 이미지는 유효한 `picsum.photos` placeholder 사용
    - 상태는 클라이언트 보존(Zustand), 새로고침 시 초기화 허용
    - 접근성: 키보드 포커스, aria-label 기본 제공

- 페이지와 라우팅(Next.js App Router)
    - `/start`: 시작 페이지(인원수, 메뉴 갯수, 메뉴 카테고리 설정)
    - `/roulette`: 룰렛 페이지(설정 기반 후보 생성·선정)
    - `/vote`: 투표 페이지(순차 투표 모드: 현재 사용자 선택→확정→다음 사용자)
    - `/result`: 결과 페이지(최종 선택 결과 표출)

- 프레젠테이션 / 비즈니스 분리
    - Presentation(화면/뷰)
        - `src/features/lunch-recommendation/components/*` 화면 컴포넌트: `Header`, `Footer`, `WaitingScreen`, `RouletteScreen`, `VotingScreen`, `ResultScreen`
        - `src/components/ui/*` shadcn-ui 컴포넌트 조합(버튼, 카드, 입력 등)
        - 특징: 상태 변이 없음, props 기반 렌더링, 이벤트 핸들러만 호출
    - Business(상태/도메인 로직)
        - `src/features/lunch-recommendation/hooks/useLunchSession.ts`: 세션 상태 오케스트레이션 훅
        - `src/features/lunch-recommendation/lib/lunchLogic.ts`: 순수 함수 모음(후보 생성, 룰렛 선택, 투표 집계, 결과 확정)
        - `src/features/lunch-recommendation/lib/mockData.ts`: 모의 데이터 소스(카테고리/메뉴)
        - `src/lib/store.ts`: Zustand 기반 전역 스토어(slicer 포함)
        - `src/features/lunch-recommendation/types.ts`: 도메인 타입 정의(zod 스키마 포함)

- 화면별 책임과 입출력(Props/Callbacks)
    - StartScreen(`/start`)
        - 입력: 인원수, 메뉴 갯수, 카테고리
        - 검증: zod 스키마로 즉시 검증
        - 동작: 설정 저장→후보 생성→`/roulette`로 이동
    - RouletteScreen(`/roulette`)
        - 입력: 현재 후보 목록
        - 동작: 룰렛 실행→단일 후보면 즉시 `/result`, 다수 후보면 `/vote`
    - VotingScreen(`/vote`)
        - 입력: 후보 목록, 남은 투표자 수
        - 동작: 단일 디바이스 순차 투표
            - 현재 사용자 선택 토글(같은 항목 재클릭 시 취소, 다른 항목 클릭 시 변경)
            - "확정" 시 현재 선택을 집계하고 다음 사용자로 진행
            - 모든 인원 완료 시 자동으로 `/result` 이동
    - ResultScreen(`/result`)
        - 입력: 최종 선택 결과(단일 후보)
        - 동작: 결과 표시, 재시작 버튼 제공(`/start`)

- 상태와 데이터 모델(요약)
    - types.ts
        - `LunchCategory` | `MenuCandidate { id: string; name: string; imageUrl: string; category: LunchCategory }`
        - `LunchPhase = 'idle' | 'started' | 'roulette' | 'voting' | 'finished'`
        - `LunchSession { id: string; participants: number; maxCandidates: number; categories: LunchCategory[]; candidates: MenuCandidate[]; votes: Record<string, number>; completedVoters: number; phase: LunchPhase; resultId?: string }`
    - zod 스키마
        - `StartFormSchema { participants: number(min 1), maxCandidates: number(min 1), categories: LunchCategory[].min(1) }`

- 비즈니스 로직(lunchLogic.ts) — 순수 함수
    - `buildCandidates(categories, max) -> MenuCandidate[]`
    - `spinRoulette(candidates) -> MenuCandidate | MenuCandidate[]` (v0: 단순 랜덤 선택/셔플)
    - `toggleCurrentSelection(prevSelection, clickedId) -> newSelection`
    - `confirmVote(votes, selectionId) -> votes` (불변 업데이트)
    - `shouldFinishVoting(participants, completedVoters) -> boolean`
    - `finalizeResult(votes, fallbackCandidateId?) -> resultId`

- 세션 훅(useLunchSession.ts) — 오케스트레이터
    - 저장소에서 세션 읽기/쓰기, 화면 전이 제어(ts-pattern으로 분기)
    - 노출 API(예시)
        - `startSession(input: StartFormSchema)` → 후보 생성, phase: 'roulette'
        - `runRoulette()` → 단일이면 result로, 다수이면 voting으로
        - `selectCandidate(candidateId)` / `clearSelection()`
        - `confirmCurrentVoter()` → 집계·완료 인원 증가·전이 판단
        - `resetSession()` → 초기화

- 저장소(store.ts) — Zustand 슬라이스 예시
    - `lunchSessionSlice`: `session: LunchSession | null`, 액션들(start, setPhase, setCandidates, setSelection, applyVote, finish)
    - 불변 업데이트 준수(es-toolkit 활용 가능)

- 상관관계(모듈 의존 흐름)
    - `page.tsx`들(`/start`, `/roulette`, `/vote`, `/result`) → 화면 컴포넌트 호출 + 훅 액션 바인딩
    - 화면 컴포넌트 → props로 데이터 표시, 이벤트 시 훅 API 호출
    - `useLunchSession` → `store` 읽기/쓰기 + `lunchLogic` 호출
    - `lunchLogic` → `types`, `mockData`만 의존(순수 함수)
    - UI 레벨에서만 `shadcn-ui`, 이미지 placeholder는 `picsum.photos`

- 분기/전이 규칙(ts-pattern 활용)
    - `phase`에 따라 허용 액션과 다음 페이지 결정
        - started → roulette, roulette → vote|result, voting → result(인원 전원 완료), finished → start

- 네비게이션/라우팅
    - App Router의 클라이언트 컴포넌트(`use client`)와 `useRouter().push()` 사용
    - 페이지 컴포넌트의 `params`는 Promise 형태로 수신(규칙 준수)

- 에러/검증/로딩
    - 시작 폼만 zod로 동기 검증
    - 나머지는 비동기 없음(v0), 스낵바는 필요 시 `use-toast` 활용

- 향후 확장 포인트(비범위)
    - 지도/장소 검색 API 연동, 멀티 디바이스 실시간 투표(supabase realtime), 세션 공유/링크 복사 고도화